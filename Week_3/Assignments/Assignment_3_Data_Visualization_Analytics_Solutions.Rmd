---
title: "Assignment_3_Data_Visualization_Analytics_Solutions"
output: pdf_document
date: "2025-06-24"
---

1) Load in the following files from the Data directory for Week 3:
- ALB_CR_2017-2018.xpt
- KIQ_U_2017-2018.xpt
- DEMO_2017-2018.xpt

a)After reading in the data, take a look at the head of each of these files. There is tons of information in there, but we will only be working with parts of each of these data frames. It's your job to pull data from these data frames to create a single data frame containing these columns from each of these files:
- ALB_CR_2017-2018.xpt: SEQN, URXUMA, URXUCR
- KIQ_U_2017-2018.xpt: KIQ022
- DEMO_2017-2018.xpt: RIDAGEYR, RIAGENDR

b) After creating the data frame, rename the columns using this key:
- SEQN : Subject_ID
- URXUMA: Albumin
- URXUCR: Creatinine
- RIDAGEYR: Age
- RIAGENDR: Sex
- KIQ022: Weak_Kidney (Have you ever been told you have weak or failing kidneys)

c) You will notice that the "Sex" variable is coded with "1" for "Male" and "2" for "Female". You will also notice that "Weak_Kidney" variable is coded with "1" for "Yes", "2" for "No", "7" for "Refused", and "9" for "Don't Know". Recode these levels from the numbers to the correct categorical variables described above. Hint: Try out the `tidyverse` package and take a look at the function called `recode()`.
```{r}
## Load the haven library to read in .xpt files
library(haven)
## Recoding the values in the columns
library(tidyverse)

## Read in files
lab_df <- read_xpt("/Users/f002yt8/Documents/GitHub/HDS-Foundations_of_Data_Science/Week_3/Data/ALB_CR_2017-2018.xpt")
kidney_df <- read_xpt("/Users/f002yt8/Documents/GitHub/HDS-Foundations_of_Data_Science/Week_3/Data/KIQ_U_2017-2018.xpt")
demographics_df <- read_xpt("/Users/f002yt8/Documents/GitHub/HDS-Foundations_of_Data_Science/Week_3/Data/DEMO_2017-2018.xpt")

## Take a look at the data
head(lab_df)
head(kidney_df)
head(demographics_df)

## Subset data frames
kidney_df <- subset(kidney_df, select = c(SEQN,KIQ022))
lab_df <- subset(lab_df, select = c(SEQN, URXUMA, URXUCR))
demographics_df <- subset(demographics_df, select = c(SEQN, RIDAGEYR, RIAGENDR))

dat_df <- merge(demographics_df, lab_df, by = "SEQN")
dat_df <- merge(dat_df, kidney_df, by = "SEQN")

## Rename columns and values in categorical variables
colnames(dat_df) <- c("Subject_ID","Age","Sex","Albumin","Creatinine","Weak_Kidney")
dat_df <- dat_df %>% mutate(Sex = recode(Sex, `1` = "Male", `2` = "Female"))
dat_df <- dat_df %>% mutate(Weak_Kidney = recode(Weak_Kidney, `1` = "Yes", `2` = "No",
                                                 `7` = "Refused", `9` = "Don't Know"))
## View data
head(dat_df)
```

2) Create a panel including the following three plots. Make sure that the labeling is publication ready!

a) The first plot should display a violin plot of creatinine (mg/dL) levels by sex. Make sure to color the violin plots by sex. This should be a ggplot2 plot. 
b) The second plot in the panel should display a scatter plot of creatinine (mg/dL) levels on the x-axis and albumin (ug/ml) levels on the y-axis. The scatter plot should have a linear regression line.
c) The final plot in the panel should be a density plot (`geom_density()`) of creatinine (mg/dL) levels by sex. Please color the density curves by sex.
```{r}
library(ggplot2)
## Generate a grid of plots
## Violin plot
p1 <- ggplot(dat_df, aes(x = Sex, y = Creatinine, fill = Sex)) +
  geom_violin(alpha = 0.7) +
  scale_fill_manual(values = c("Male" = "blue", "Female" = "red")) +
  labs(title = "Violin Plot of Creatinine",
       x = "",
       y = "Creatinine (mg/dL)")

print(p1)

## Scatter plot of albumin and creatinine
p2 <- ggplot(dat_df, aes(Creatinine,Albumin)) + geom_point() + 
  geom_smooth(method="lm") +
  labs( y="Albumin (ug/ml)", 
       x="Creatinine (mg/dL)", 
       title="Scatterplot of Albumin (ug/ml) \nvs. Creatinine (mg/dL)")
print(p2)

## Denisty plot of albumin
p3 <- ggplot(dat_df, aes(Creatinine)) + geom_density(aes(fill=factor(Sex)), alpha=0.8) + 
    labs(title="Density of Creatinine (mg/dL) by Sex", 
         subtitle="Creatinine (mg/dL) by Sex",
         x="Creatinine (mg/dL)",
         fill="Sex")

plots <- ggarrange(p1, p2, p3, ncol = 2, nrow = 2)
print(plots)
```
3) Create a function that takes the data frame above we have been working with, continuous variable, categorical variable, name of continuous variable as you would like it to appear in labels and titles, and name of categorical variable as you would like it to appear in labels and titles. The function should create a box plot of the continuous variable by the categorical variable. The plot should also display the p-value comparing the results of a Wilcoxon Rank Sum Test between the categorical variable levels. Calculate the mean and standard deviation of the continuous variable. Using the `geom_text()` function add the mean and standard deviation to the plot below the p-value. Make sure to provide a title, appropriate labels, and colors! 
```{r}
my_fun <- function(df, cat_var, con_var, cat_name, con_name) {
  # Compute mean and sd of con_var (overall)
  mean_con <- mean(df[[con_var]], na.rm = TRUE)
  sd_con <- sd(df[[con_var]], na.rm = TRUE)
  
  library(ggplot2)
  library(ggpubr)
  
  bx_plt <- ggplot(df, aes_string(x = cat_var, y = con_var, fill = cat_var)) +
    geom_boxplot(width = 0.5) +
    labs(title = paste0("Box Plot of ", con_name, " by ", cat_name),
         x = cat_name,
         fill = cat_name,
         y = con_name) +
    scale_fill_manual(values = c("#F4B147", "#CF3E4A")) +
    stat_compare_means(method = "wilcox", label.x = 1.3, label.y = max(df[[con_var]], na.rm = TRUE) * 0.95, size = 3) + 
    geom_text(aes(x = 1.5, y = max(df[[con_var]], na.rm=TRUE)*0.9, 
                  label = paste0("Mean: ", round(mean_con, 2))),
              inherit.aes = FALSE, size = 3) +
    geom_text(aes(x = 1.5, y = max(df[[con_var]], na.rm=TRUE)*0.85, 
                  label = paste0("SD: ", round(sd_con, 2))),
              inherit.aes = FALSE, size = 3)
  
  print(bx_plt)
}

my_fun(df = dat_df, cat_var = "Sex", con_var = "Creatinine", cat_name = "Sex", con_name = "Creatinine (mg/dL)")
```

4) Using a for loop create 5 random data frames containing the following columns:

- Participant ID: There should be 100 participants in each data frame with unique identifiers.
- Sex: Sex should be comprised of two levels - Male and Female
- Age: This data frame should contain only adults between 18 and 85.
- Red Blood Cell Count: Female: 3.92 - 5.13 cells/L (trillion), Male: 4.35-5.65 cells/L (trillion)
- White Blood Cell Count: 3.4-9.6 cell/L (billion)

Put these data frames into a list. 
```{r}
my_dfs <- list()
n=100
for (i in 1:5){
  n = 100
  Sex <- sample(c("Male", "Female"), n, replace = TRUE)
  
  Red_Blood_Cell <- numeric(n)
  
  # For females
  female_idx <- which(Sex == "Female")
  Red_Blood_Cell[female_idx] <- round(runif(length(female_idx), min = 3.92, max = 5.13), 2)
  
  # For males
  male_idx <- which(Sex == "Male")
  Red_Blood_Cell[male_idx] <- round(runif(length(male_idx), min = 4.35, max = 5.65), 2)
  
  df <- data.frame(Participant_ID = paste("P", 1:n, sep = "_"),
                   Age = pmax(18, pmin(85, round(rnorm(n, mean = 50, sd = 10)))),
                   Sex = Sex,
                   White_Blood_Cells = round(runif(n, min = 3.4, max = 9.6), 2),
                   Red_Blood_Cell = Red_Blood_Cell)
  
  my_dfs[[i]] <- df
}

dim(my_dfs[[1]])
```


5) For each of the data frames you generated in the previous question, create a scatter plot with the red blood cell count on the x-axis and the white blood cell count on the y-axis. Color the points by Sex. Once you have created these plots, arrange the plots in a panel using `ggarrange()`. Hint: Make a list of the plots that you can apply to the function `do.call()` along with `ggarrange()`! 

```{r}
library(ggplot2)
library(ggpubr)

plot_list <- list()
i <- 1
for (df in my_dfs) {
  my_plot <- ggplot(df, aes(x = Red_Blood_Cell, y = White_Blood_Cells, fill = Sex)) +
    geom_point(size = 2, shape = 23) +
    labs(title = "White and \nRed Blood Cell Levels",
         x = "Red Blood Cells",
         y = "White Blood Cells")
  plot_list[[i]] <- my_plot
  i <- i + 1
}

do.call(ggarrange, c(plot_list, ncol = 2, nrow = 3))
```

